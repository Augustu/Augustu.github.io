[{"uri":"https://www.didida.top/kubernetes/introduction/","title":"Introduction","tags":[],"description":"","content":"Kubernetes  服务发现和负载均衡 存储编排 自动部署和回滚 自动完成装箱计算 自我修复 密钥与配置管理  Kubernetes 组件   控制平面组件（Control Plane Components）\n  kube-apiserver\n  etcd\n  kube-scheduler\n  kube-controller-manager\n从逻辑上讲，每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。\n  节点控制器（Node Controller）\n负责在节点出现故障时进行通知和响应。\n  副本控制器（Replication Controller）\n负责为系统中的每个副本控制器对象维护正确数量的 Pod。\n  端点控制器（Endpoints Controller）\n填充端点(Endpoints)对象(即加入 Service 与 Pod)。\n  服务帐户和令牌控制器（Service Account \u0026amp; Token Controllers）\n为新的命名空间创建默认帐户和 API 访问令牌。\n    cloud-controller-manager\n  节点控制器（Node Controller）\n用于在节点终止响应后检查云提供商以确定节点是否已被删除。\n  路由控制器（Route Controller）\n用于在底层云基础架构中设置路由。\n  服务控制器（Service Controller）\n用于创建、更新和删除云提供商负载均衡器。\n      Node 组件\n节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境。\n  kubelet\n  kube-proxy\n  容器运行时（Container Runtime）\nKubernetes 支持多个容器运行环境: Docker、 containerd、CRI-O 以及任何实现 Kubernetes CRI (容器运行环境接口)。\n    插件（Addons）\n DNS Web 界面（仪表盘） 容器资源监控 集群层面日志    节点（node） Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的工作负载。\n"},{"uri":"https://www.didida.top/kubernetes/","title":"Kubernetes","tags":[],"description":"","content":"Kubernetes Install sudo cp * /usr/bin/ sudo mkdir -p /etc/systemd/system/kubelet.service.d echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward ebtables sudo kubeadm init --image-repository registry.aliyuncs.com/google_containers sudo vi /etc/kubernetes/kubelet.env # add --fail-swap-on=false sudo kubeadm init \\ \t--kubernetes-version=v1.20.2 \\ \t--image-repository registry.aliyuncs.com/google_containers \\ \t--ignore-preflight-errors=all \\ \t--apiserver-advertise-address=10.10.10.11 \\ \t--pod-network-cidr=10.10.0.0/16 \\ \t--v=5 sudo kubeadm init \\ \t--kubernetes-version=v1.20.2 \\ \t--image-repository registry.aliyuncs.com/google_containers \\ \t--ignore-preflight-errors=all \\ \t--apiserver-advertise-address=192.168.0.103 \\ \t--pod-network-cidr=10.10.0.0/16 \\ \t--v=5 sudo systemctl enable --now kubelet kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml ref: https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/\n[addons] Applied essential addon: CoreDNS [addons] Applied essential addon: kube-proxy Your Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config Alternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.conf You should now deploy a pod network to the cluster. Run \u0026#34;kubectl apply -f [podnetwork].yaml\u0026#34; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ Then you can join any number of worker nodes by running the following on each as root: kubeadm join 192.168.0.103:6443 --token gd4fkv.f0rg29z4sjlrki6o \\  --discovery-token-ca-cert-hash sha256:a46f8c0ec42d43c2089b464d5af8050e135b934a63cd6759c12496f35185cee "},{"uri":"https://www.didida.top/docker/redis/","title":"Redis","tags":[],"description":"","content":"Redis docker pull redis docker run --name redis-bench \\ \t-v /home/Develop/data/redis/conf:/data \\ \t-p 127.0.0.1:6379:6379 \\ \t-d redis docker run --name redis-bench \\ \t-p 127.0.0.1:6379:6379 \\ \t-d redis Redis 集合(Set)    命令 描述     SADD key member1 [member2] 向集合添加一个或多个成员   SCARD key 获取集合的成员数   SDIFF key1 [key2] 返回第一个集合与其他集合之间的差异   SDIFFSTORE destination key1 [key2] 返回给定所有集合的差集并存储在 destination 中   SINTER key1 [key2] 返回给定所有集合的交集   SINTERSTORE destination key1 [key2] 返回给定所有集合的交集并存储在 destination 中   SISMEMBER key member 判断 member 元素是否是集合 key 的成员   SMEMBERS key 返回集合中的所有成员   SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合   SPOP key 移除并返回集合中的一个随机元素   SRANDMEMBER key [count] 返回集合中一个或多个随机数   SREM key member1 [member2] 移除集合中一个或多个成员   SUNION key1 [key2] 返回所有给定集合的并集   SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中   SSCAN key cursor [MATCH pattern] [COUNT count] 迭代集合中的元素    ref: https://www.runoob.com/redis/redis-sets.html\nRedis 有序集合(sorted set)    序号 命令 描述     1 ZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数   2 ZCARD key 获取有序集合的成员数   3 ZCOUNT key min max 计算在有序集合中指定区间分数的成员数   4 ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 increment   5 ZINTERSTORE destination numkeys key [key \u0026hellip;] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中   6 ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量   7 ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合指定区间内的成员   8 ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员   9 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员   10 ZRANK key member 返回有序集合中指定成员的索引   11 ZREM key member [member \u0026hellip;] 移除有序集合中的一个或多个成员   12 ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员   13 ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员   14 ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员   15 ZREVRANGE key start stop [WITHSCORES] 返回有序集中指定区间内的成员，通过索引，分数从高到低   16 ZREVRANGEBYSCORE key max min [WITHSCORES] 返回有序集中指定分数区间内的成员，分数从高到低排序   17 ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序   18 ZSCORE key member 返回有序集中，成员的分数值   19 ZUNIONSTORE destination numkeys key [key \u0026hellip;] 计算给定的一个或多个有序集的并集，并存储在新的 key 中   20 ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值）    ref: https://www.runoob.com/redis/redis-sorted-sets.html\n"},{"uri":"https://www.didida.top/docker/rabbitmq/","title":"Rabbitmq","tags":[],"description":"","content":"RabbitMQ docker pull rabbitmq:management docker run --name rabbitmq-bench \\ \t-p 127.0.0.1:15672:15672 \\ \t-p 127.0.0.1:5672:5672 \\ \t-p 127.0.0.1:15692:15692 \\ \t-e RABBITMQ_DEFAULT_USER=admin \\ \t-e RABBITMQ_DEFAULT_PASS=123456 \\ \t-d rabbitmq:management exchange ref: https://www.rabbitmq.com/tutorials/tutorial-three-go.html\ntypes:\n  direct\n  topic\n  headers\n  fanout\nIt just broadcasts all the messages it receives to all the queues it knows\n  queue producer consumer "},{"uri":"https://www.didida.top/operate-system/introduction/","title":"Introduction","tags":[],"description":"","content":"操作系统的主要功能  从资源管理器的观点来看，操作系统的任务是高效地管理整个系统的各个部分； 从扩展机的观点来看，其任务是为用户提供一台比物理计算机更易于使用的虚拟计算机；  系统调用 与进程有关，与文件系统有关\n 与进程的创建和终止有关 处理信号 针对文件读写 进行目录管理 对信息进行保护 用于时间管理  操作系统结构   整体结构\n整个操作系统是一组函数的集合，其中每个函数在需要的时候可以去调用任何其他的函数\n  分层结构\n把整个操作系统组织成一个层次结构，每一层软件都是在它的下层软件的基础上构造起来的\n  虚拟机\n  外核\n外核程序管理资源分配\n  客户-服务器模型\n消息请求回复\n  操作系统  进程管理 I/O设备管理 存储管理 文件管理  进程   通信\n  调度\n时钟中断 非抢占式调度算法 抢占式调度算法\n  所有系统\n公平 策略强制执行 平衡\n  批处理系统\n吞吐量 周转时间 CPU利用率\n 非抢占式调度算法  先到先服务 最短作业优先   抢占式调度算法  最短剩余时间优先   三级调度  准入调度器 内存调度器 CPU调度器      交互式系统\n响应时间 均衡性\n两级调度： 内存调度 CPU调度\n 时间片轮转调度 优先级调度 多重队列 最短进程优先 保证调度算法 彩票调度算法 公平分享调度    实时系统\n满足截至时间 可预测性\n系统： 硬实时 软实时\n时间： 周期性 非周期性\n  策略与机制\n  线程调度\n    "},{"uri":"https://www.didida.top/operate-system/","title":"Operate System","tags":[],"description":"","content":""},{"uri":"https://www.didida.top/docker/mysql/","title":"Mysql","tags":[],"description":"","content":"mysql docker pull mysql:5.7 # 拉取 mysql 5.7 docker pull mysql # 拉取最新版mysql镜像 docker run -p 3306:3306 --name mysql-bench \\ -v /run/media/mike/Data/Develop/data/mysql/tmp:/tmp \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -d mysql docker run -p 127.0.0.1:3306:3306 --name mysql-bench \\ -v /home/mike/Develop/data/mysql/conf:/etc/mysql \\ -v /home/mike/Develop/data/mysql/mysql:/var/lib/mysql \\ -v /home/mike/Develop/data/mysql/mysql-files:/var/lib/mysql-files \\ -v /home/mike/Develop/data/mysql/logs:/var/log/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -d mysql mysql -h 127.0.0.1 -P 3306 -u root -p 123456 ref: https://www.cnblogs.com/sablier/p/11605606.html\nbench sysbench sysbench /usr/share/sysbench/oltp_read_write.lua \\ \t--tables=5 \\ \t--table_size=100 \\ \t--mysql-user=root \\ \t--mysql-password=123456 \\ \t--mysql-host=127.0.0.1 \\ \t--mysql-port=3306 \\ \t--mysql-db=sysbench_test \\ \tprepare sysbench /usr/share/sysbench/oltp_read_write.lua \\ \t--tables=1 \\ \t--table_size=10000000 \\ \t--mysql-user=root \\ \t--mysql-password=123456 \\ \t--mysql-host=127.0.0.1 \\ \t--mysql-port=3306 \\ \t--mysql-db=sysbench_test \\ \tprepare sysbench /usr/share/sysbench/oltp_read_write.lua \\ \t--mysql-user=root \\ \t--mysql-password=123456 \\ \t--mysql-host=127.0.0.1 \\ \t--mysql-port=3306 \\ \t--mysql-db=sysbench_test \\ \t--tables=5 \\ \t--table_size=100 \\ \t--threads=10 \\ \t--time=30 \\ \t--report-interval=3 \\ \trun ref: https://www.cnblogs.com/jinjiangongzuoshi/p/13883129.html\n"},{"uri":"https://www.didida.top/docker/monitor/","title":"Monitor","tags":[],"description":"","content":"Monitor docker pull prom/prometheus docker pull prom/node-exporter docker pull grafana/grafana docker run --name archlinux \\ \t-p 127.0.0.1:9100:9100 \\ \t-v /proc:/host/proc:ro \\ \t-v /sys:/host/sys:ro \\ \t-v /:/rootfs:ro \\ \t--net=host \\ \t-d prom/node-exporter docker run --name mysqld-exporter-mysql-bench \\ \t-p 127.0.0.1:9104:9104 \\ \t--link=mysql-bench:mysql \\ \t-e DATA_SOURCE_NAME=\u0026#34;root:123456@(mysql:3306)/\u0026#34; \\ \t-d prom/mysqld-exporter docker run --name prometheus \\ \t-p 127.0.0.1:9090:9090 \\ \t-v /home/mike/Develop/data/prometheus/conf/prometheus.yml:/etc/prometheus/prometheus.yml \\ \t-d prom/prometheus docker run --name=grafana \\ \t-p 127.0.0.1:3000:3000 \\ \t-v /home/mike/Develop/data/grafana/data:/var/lib/grafana \\ \t-d grafana/grafana # admin:admin -\u0026gt; admin:123456 # dashboard # 系统监控 1 Node Exporter for Prometheus Dashboard CN v20201010 https://grafana.com/grafana/dashboards/8919 # RabbitMQ-Overview https://grafana.com/grafana/dashboards/10991 "},{"uri":"https://www.didida.top/docker/gitlab/","title":"Gitlab","tags":[],"description":"","content":"Gitlab docker run --name gitlab \\ \t-p 127.0.0.1:22:22 \\ \t-p 127.0.0.1:443:443 \\ \t-p 127.0.0.1:80:80 \\ \t-d gitlab/gitlab-ce docker run --name gitlab \\ \t-p 127.0.0.1:22:22 \\ \t-p 127.0.0.1:443:443 \\ \t-p 127.0.0.1:80:80 \\ \t--hostname gitlab.org \\ \t-v /home/Mount/Develop/data/gitlab/etc:/etc/gitlab \\ \t-v /home/Mount/Develop/data/gitlab/opt:/var/opt/gitlab \\ \t-v /home/Mount/Develop/data/gitlab/log:/var/log/gitlab \\ \t-d gitlab/gitlab-ce Kubernetes cluster https://hub.docker.com/r/gitlab/gitlab-ce\n"},{"uri":"https://www.didida.top/docker/elk/","title":"Elk","tags":[],"description":"","content":"ELK Run docker pull sebp/elk docker run --name elk \\ \t-p 127.0.0.1:5601:5601 \\ \t-p 127.0.0.1:9200:9200 \\ \t-p 127.0.0.1:5044:5044 \\ \t-e ES_HEAP_SIZE=\u0026#34;2g\u0026#34; \\ \t-e LS_HEAP_SIZE=\u0026#34;1g\u0026#34; \\  -v /home/Develop/data/elk/es-data:/var/lib/elasticsearch \\ \t-v /home/Develop/data/elk/logstash:/etc/logstash \\ \t--link redis-bench:redis \\ \t-d sebp/elk # -e TZ=\u0026#34;Asia/Shanghai\u0026#34; \\ ref: https://elk-docker.readthedocs.io/#running-with-docker-compose\nissue   max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]\nsudo vi /etc/sysctl.conf vm.max_map_count=655360 sudo sysctl -p ref: https://blog.csdn.net/tl1242616458/article/details/105602361/\n   "},{"uri":"https://www.didida.top/docker/etcd/","title":"Etcd","tags":[],"description":"","content":"Etcd Install docker pull quay.io/coreos/etcd docker run --name etcd-node1 \\ \t-p 127.0.0.1:2379:2379 \\ \t-p 127.0.0.1:2380:2380 \\ \t-e ALLOW_NONE_AUTHENTICATION=yes \\ \t-e ETCD_NAME=node1 \\ \t-d bitnami/etcd docker run --name e3w \\ \t-p 127.0.0.1:8030:8080 \\ \t--link etcd-node1:etcd \\ \t-d soyking/e3w docker run --name etcd-node1 \\ \t-p 127.0.0.1:2379:2379 \\ \t-p 127.0.0.1:2380:2380 \\ \t-e ETCD_LISTEN_CLIENT_URLS=http://127.0.0.1:2379 \\ \t-e ETCD_LISTEN_PEER_URLS=http://127.0.0.1:2380 \\ \t-e ETCD_INITIAL_ADVERTISE_PEER_URLS=http://127.0.0.1:2380 \\ \t-e ALLOW_NONE_AUTHENTICATION=yes \\ \t-e ETCD_INITIAL_CLUSTER=node1=http://127.0.0.1:2380 \\ \t-e ETCD_NAME=node1 \\ \t-d bitnami/etcd docker run --name etcd-node1 \\ \t-p 127.0.0.1:2379:2379 \\ \t-p 127.0.0.1:2380:2380 \\ \t-d quay.io/coreos/etcd # In this example, all three of these containers will be running on the same machine. Here are the three docker run commands that will get the cluster up and running. First, export a variable with your public IP address: export PUBLIC_IP=54.196.167.255 # And then start up our leader + two followers: docker run -d -p 8001:8001 -p 5001:5001 quay.io/coreos/etcd:v0.4.6 -peer-addr ${PUBLIC_IP}:8001 -addr ${PUBLIC_IP}:5001 -name etcd-node1 docker run -d -p 8002:8002 -p 5002:5002 quay.io/coreos/etcd:v0.4.6 -peer-addr ${PUBLIC_IP}:8002 -addr ${PUBLIC_IP}:5002 -name etcd-node2 -peers ${PUBLIC_IP}:8001,${PUBLIC_IP}:8002,${PUBLIC_IP}:8003 docker run -d -p 8003:8003 -p 5003:5003 quay.io/coreos/etcd:v0.4.6 -peer-addr ${PUBLIC_IP}:8003 -addr ${PUBLIC_IP}:5003 -name etcd-node3 -peers ${PUBLIC_IP}:8001,${PUBLIC_IP}:8002,${PUBLIC_IP}:8003 ref: https://www.cnblogs.com/hatlonely/p/11945491.html\nref: https://coreos.com/blog/running-etcd-in-containers.html\n"},{"uri":"https://www.didida.top/docker/","title":"Docker","tags":[],"description":"","content":"Docker Config sudo vim /etc/docker/daemon.json { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;], \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], \u0026#34;graph\u0026#34;: \u0026#34;/home/Develop/data/docker\u0026#34; } sudo systemctl restart docker sudo usermod -a -G users $USER "},{"uri":"https://www.didida.top/compiler/introduction/","title":"简介","tags":[],"description":"","content":"编程语言是向人和计算机描述计算过程的记号，程序必须翻译成可以被计算机执行的形式，完成这个翻译过程的软件系统叫做编译器。\n语言处理 编译器的结构 分析（analysis） 合成（synthesis） 编程语言的演变 制作编译器的科学 编译器技术的应用 编程语言基础 总结 "},{"uri":"https://www.didida.top/compiler/","title":"编译器","tags":[],"description":"","content":""},{"uri":"https://www.didida.top/compiler/a-simple-syntax-directed-translator/","title":"简单的语法制导翻译","tags":[],"description":"","content":"语法制导翻译 介绍 语法定义 语法制导翻译 语法解析 简单表达式的翻译 词法分析 符号表 中间代码生成 "},{"uri":"https://www.didida.top/golang/quick-start/install/","title":"安装","tags":[],"description":"","content":"ref: https://golang.org/\n"},{"uri":"https://www.didida.top/golang/","title":"Golang","tags":[],"description":"","content":"Golang Go 语言学习中的整理和总结。\n  Quick Start\ngo 语法和语言特性的整理\n   "},{"uri":"https://www.didida.top/leetcode/","title":"LeetCode","tags":[],"description":"","content":"LeetCode LeetCode 刷题记录\n"},{"uri":"https://www.didida.top/","title":"主页","tags":[],"description":"","content":"简介 这是一个记录程序员个人成长的网站，也是督促自己学习进步的一个项目，旨在记录学习过程中的心得体会，避免走第二次弯路。\n"},{"uri":"https://www.didida.top/golang/quick-start/","title":"入门","tags":[],"description":"","content":"Golang test\n"},{"uri":"https://www.didida.top/golang/quick-start/quick-start/","title":"语言特性","tags":[],"description":"","content":"Go 语言学习 "},{"uri":"https://www.didida.top/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://www.didida.top/tags/","title":"Tags","tags":[],"description":"","content":""}]